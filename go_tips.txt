2020/1/7

1.Println 和 Printf的区别

Println:  可以打印出字符串，和变量
Printf：只可以打印出格式化的字符串，可以输入字符串类型的变量，不可以输出整型变量和整型

eg: a := 10
fmt.Println(a)  //right
fmt.Println("abc")  //right
fmt.Printf("%d", a)  //right
fmt.Printf(a)  // error

p := point{1, 2}
fmt.Printf("%v\n", p)

2020/1/8

1.变量声明
var 变量名字  类型  = 表达式
其中"类型"或 "=表达式" 两个部分可以省略其中一个。如果省略的是类型信息，那么将根据初始化表达式来推到变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型(包括slice、指针、map、chan和函数)变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

var i, j, k int                	 // int, int, int
var b, f, s = true, 2.3, "four"	 // bool, float64, string

一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：
var f, err = os.Open(name) // os.Open returns a file and an error

尽量采用驼峰命名，首字母小写意为 私有， 首字母大写意为公有

2. 简短变量声明
在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以 "名字 := 表达式" 形式声明变量，变量的类型根据表达式自动推导。
eg: 
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0

var形式的声明语句往往是用于需要显示指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

i := 100                  // an int
var boiling float64 = 100 // a float64
var names []string
var err error
var p Point

和var形式声明语句一样，间段变量声明语句也可以用来声明和初始化以组变量：
i, j = 0, 1
 但是这种同时声明多个变量的方式应该限制只可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。

“:=”是一个变量声明语句，而“=”是一个变量赋值操作。
eg:  i, j = j, i  //交换 i 和 j 的值

简短变量声明语句也可以用函数的返回值来声明和初始化变量
f, err := os.Open(name)
if err != nil {
    return err
}
// ...use f...
f.Close()

如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。

在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作。

in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)

简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：

f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables

3. 指针

x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"



2020/1/9

1.任何类型的指针的零值都是nil。

var k *int
fmt.Println(k)  	// <nil>

2.因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。
func incr(p *int) int {
    *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
    return *p
}

v := 1
incr(&v)              // side effect: v is now 2
fmt.Println(incr(&v)) // "3" (and v is 3)

***赋值***
3. 元组赋值也可以使一些列琐碎赋值更加紧凑(特别是在for循环的初始部分)
i, j, k = 2, 3, 5
  但如果表达式太复杂，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。

4.当一个函数调用出现在元组赋值有右边的表达式中时(！！右边不能再有其他表达式)，左边数量的数目必须和右边一致

f, err = os.Open("foo.txt") // function call returns two values
	通常这类函数会用额外的返回值来表达某种错误类型。
他们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：
v, ok = m[key]	// map lookup (map查找)
v, ok = x.(T)	// type assertion (类型断言)
v, ok = <-ch	// channel receive (通道接收)

map查找、类型断言或通道接收 出现在赋值语句的右边时，并不一定是产生两个结果。对于值产生的一个结果的情形，map查找失败时会返回零值，类型断言失败时会发送运行时panic异常，通道接收失败时会返回零值（阻塞不算失败）。
v = m[key]	//map查找，失败时返回零值
v = x.(T)		//type断言，失败时panic异常
v = <-ch		//管道接收，失败时返回零值（阻塞不算失败）

_, ok = m[key]	// map返回2个值
_, ok = mm[""]	// map返回1个值
_ = mm[""] 	// map返回1个值

和变量声明一样，我们可以用下划线空白标识符 _ 来丢弃不需要的值
_, err = io.Copy(dst, src)	//丢弃字节数
_, ok = x.(T)		//只检测类型，忽略具体值

5.不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。


2020/1/10
***类型***
1.类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用
	type 类型名字 底层类型


2020/1/15
***2,7作用域***
1.声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内，它可以被程序的其他部分引用；是一个运行时的概念。

***三   基础数据类型***      ------>基础类型、复合类型、引用类型和接口类型
	基础类型：数字、字符串和布尔型
	复合数据类型：数组和结构体是通过组合简单类型，来表达更加复杂得数据结构。
	引用类型：指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中得一个变量或状态得间接引用。

1.在GO语言中，% 取模运算符的和被取模数的符号总是一致的，因此 -5%3 和 -5%-3 结果都是-2.
	除法运算符 / 的行为则依赖于操作数是否为全为整数，比如 5.0/4.0（5/4.0、5.0/4） 的结果是1.25，
	但 5/4 的结果是 1， 因为整数除法会向着0方向截断余数

2020/1/16
***3.1 整型***
1. 对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度；
f := 3.141 // a float64
i := int(f)	// 3
    应该避免对可能会超出目标类型表示范围的数值类型转换，因为截断的行为可能依赖于具体的实现
f := 1e100  // a float64
i := int(f)  	//  -9223372036854775808  // 结果依赖于具体实现  

2. 任何大小的整数字面值都可以用0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。

2020/1/17
***3.2 浮点数***
1. 通常应优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（ 因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：
var f float32 = 16777216  // 1 << 24
fmt.Println(f == f+1) 

2. 浮点数的字面值可以直接写小数部分
const e = 2.71828 // (approximately)

***3.3 复数***

1.Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。
内置的complex函数用于构建复数，内建的real和imag函数分别返回符数的实部和虚部：
var x complex128 = complex(1, 2)  // 1+2i
var y complex128 = complex(3, 4)  // 3+4i
fmt.Println(x*y)		     // (-5+10i)
fmt.Println(real(x*y))		     // -5
fmt.Println(imag(x*y)) 	     // 10
2. 如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0：
fmt.Println(1i * 1i)   // (-1+0i),  i^2 = -1
3. 在常量算数规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i 或与之等价的写法 2i+1。上面x和y的声明语句还可以简化：
x := 1 + 2i
y := 3 + 3i
4. 复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的。










